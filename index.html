<!doctype html>
<html lang="en">
  <meta name="viewport" content="width=device-width, initial-scale-1.0">
  <title>Multiplication Sky Runner</title>
  <script src="/_sdk/element_sdk.js"></script>
  <!-- MODIFICATION: Add Tone.js for audio effects -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
        :root {
            --character-emoji: 'üê∞';
        }

        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
            height: 100%;
            overflow: hidden;
            user-select: none;
        }

        html {
            height: 100%;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 600px;
        }

        .clouds {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(ellipse 80px 40px at 100px 100px, white 40%, transparent 50%),
                radial-gradient(ellipse 60px 30px at 300px 150px, white 40%, transparent 50%),
                radial-gradient(ellipse 100px 50px at 500px 80px, white 40%, transparent 50%),
                radial-gradient(ellipse 70px 35px at 700px 200px, white 40%, transparent 50%);
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { transform: translateX(0); }
            100% { transform: translateX(-200px); }
        }

        .ui-panel {
            position: absolute;
            top: 10px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            /* MODIFICATION: Doubled top/bottom padding */
            padding: 20px 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 100;
            /* MODIFICATION: Removed fixed height to make panel shorter */
            /* height: 60px; */
            /* max-height: 10%; */
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            /* MODIFICATION: Added gap for spacing */
            gap: 15px;
            /* MODIFICATION: Removed margin-bottom */
            /* margin-bottom: 8px; */
        }

        .level-display {
            font-size: 16px;
            font-weight: bold;
            color: #2E8B57;
        }

        .lives-display {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        #lives-container {
            display: flex;
            gap: 4px;
        }

        .heart {
            width: 18px;
            height: 18px;
            background: #FF6B6B;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            transform: rotate(-45deg);
            position: relative;
        }

        .heart::before {
            content: '';
            width: 9px;
            height: 14px;
            position: absolute;
            left: 9px;
            top: 0;
            background: #FF6B6B;
            border-radius: 50px 50px 0 0;
            transform: rotate(-45deg);
            transform-origin: 0 100%;
        }

        .heart::after {
            content: '';
            width: 9px;
            height: 14px;
            position: absolute;
            left: 0;
            top: -4px;
            background: #FF6B6B;
            border-radius: 50px 50px 0 0;
            transform: rotate(45deg);
            transform-origin: 100% 100%;
        }

        .score-display {
            font-size: 14px;
            font-weight: bold;
            color: #4169E1;
        }

        .question-display {
            text-align: center;
            /* MODIFICATION: Doubled font size */
            font-size: 28px;
            font-weight: bold;
            color: #2E8B57;
            background: #F0F8FF;
            padding: 4px 8px;
            border-radius: 6px;
            border: 2px solid #4169E1;
            /* MODIFICATION: Adjusted styles for flex layout */
            flex-grow: 1; /* Take up remaining space */
            margin: 0 10px; /* Add some spacing */
            /* max-width: 150px; */
            /* margin: 0 auto; */
        }

        .character {
            position: absolute;
            left: 80px;
            width: 60px;
            height: 60px;
            background: #FFB6C1;
            border-radius: 50%;
            border: 3px solid #FF69B4;
            transition: top 0.1s ease;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }

        .character::before {
            content: var(--character-emoji);
            font-size: 40px;
        }

        .answer-option {
            position: absolute;
            right: -600px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #FFE4E1, #FFB6C1, #FF69B4);
            border: 3px solid #FF1493;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            /* MODIFICATION: Doubled font size */
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4), inset 0 2px 6px rgba(255, 255, 255, 0.3);
            animation: moveLeft 8s linear, candyShine 2s ease-in-out infinite alternate;
            /* * BUG FIX: Removed 'position: relative;' which was overriding 
             * 'position: absolute;' and breaking the animation.
             * Also set animation 'infinite' to just 'linear' for moveLeft
             * as it should only run once per candy.
            */
        }

        .answer-option::before {
            /* MODIFICATION: Changed to candy icon */
            content: 'üç¨';
            position: absolute;
            top: -8px;
            right: -5px;
            font-size: 20px;
            z-index: 1;
        }

        .answer-option::after {
            content: '';
            position: absolute;
            top: 20px;
            left: 25px;
            width: 20px;
            height: 15px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: rotate(-20deg);
        }

        .answer-option.correct {
            background: radial-gradient(circle at 30% 30%, #E6FFE6, #90EE90, #32CD32);
            border-color: #228B22;
        }

        .answer-option.correct::before {
            /* MODIFICATION: Removed icon override */
            /* content: 'üç¨'; */
        }

        .answer-option.wrong {
            background: radial-gradient(circle at 30% 30%, #FFE4B5, #FFD700, #FFA500);
            border-color: #FF8C00;
        }

        .answer-option.wrong::before {
            /* MODIFICATION: Removed icon override */
            /* content: 'üßÅ'; */
        }

        @keyframes candyShine {
            0% { box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.3); }
            100% { box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5), inset 0 4px 12px rgba(255, 255, 255, 0.5); }
        }

        @keyframes moveLeft {
            0% { right: -600px; }
            100% { right: 100%; }
        }

        .game-over-screen, .level-complete-screen, .level-select-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .level-select-screen {
            display: flex;
        }

        .level-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .level-btn {
            padding: 20px;
            text-align: left;
            background: linear-gradient(45deg, #32CD32, #228B22);
            min-width: 250px;
        }

        .level-btn:hover {
            background: linear-gradient(45deg, #228B22, #006400);
        }

        .level-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .level-desc {
            font-size: 16px;
            margin-bottom: 3px;
            opacity: 0.9;
        }

        .level-example {
            font-size: 14px;
            opacity: 0.8;
        }

        .modal {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            color: #2E8B57;
            margin-bottom: 20px;
            font-size: 36px;
        }

        .modal p {
            font-size: 20px;
            margin-bottom: 30px;
            color: #333;
        }

        .btn {
            background: linear-gradient(45deg, #4169E1, #6495ED);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            color: #333;
        }

        .touch-controls {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 60;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, rgba(255, 107, 107, 0.4), rgba(255, 142, 142, 0.4));
            border: 2px solid rgba(255, 68, 68, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .control-btn.up {
            background: linear-gradient(45deg, rgba(76, 175, 80, 0.4), rgba(102, 187, 106, 0.4));
            border-color: rgba(56, 142, 60, 0.5);
        }

        .control-btn.down {
            background: linear-gradient(45deg, rgba(33, 150, 243, 0.4), rgba(66, 165, 245, 0.4));
            border-color: rgba(25, 118, 210, 0.5);
        }

        .feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .feedback.correct {
            color: #32CD32;
        }

        .feedback.wrong {
            color: #FF4500;
        }

        .feedback.show {
            opacity: 1;
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <!-- CLEANUP: Removed unused Tailwind CSS script -->
 </head>
 <body>
  <div class="game-container">
   <div class="clouds"></div>
   <div class="ui-panel">
    <div class="game-stats">
     <div class="level-display">
      Level <span id="current-level">1</span>
     </div>
     <!-- MODIFICATION: Moved Lives, Question, Score into one flex row -->
     <div class="lives-display"><span>Lives: </span>
      <div id="lives-container">
       <div class="heart"></div>
       <div class="heart"></div>
       <div class="heart"></div>
      </div>
     </div>
     <div class="question-display" id="question">
      2 √ó 3 = ?
     </div>
     <div class="score-display">
      Score: <span id="score">0</span>
     </div>
    </div>
    <!-- MODIFICATION: Question display is now inside .game-stats -->
   </div>
   <div class="character" id="character"></div>
   <div class="touch-controls">
    <div class="control-btn up" id="up-btn">
     ‚Üë
    </div>
    <div class="control-btn down" id="down-btn">
     ‚Üì
    </div>
   </div>
   <div class="feedback" id="feedback"></div>
   <div class="controls-info"><strong>Controls:</strong><br>
     Touch buttons or use keyboard<br>
     ‚Üë/‚Üì Arrow Keys or W/S
   </div>
   <div class="game-over-screen" id="game-over-screen">
    <div class="modal">
     <h2>Game Over!</h2>
     <p>Final Score: <span id="final-score">0</span></p>
     <p>Level Reached: <span id="final-level">1</span></p><button class="btn" onclick="restartGame()">Play Again</button>
    </div>
   </div>
   <!-- MODIFICATION: Removed unused level-complete-screen -->
   <!--
   <div class="level-complete-screen" id="level-complete-screen">
    <div class="modal">
     <h2>Level Complete! üéâ</h2>
     <p>Great job! Ready for the next challenge?</p><button class="btn" onclick="nextLevel()">Next Level</button>
    </div>
   </div>
   -->
   <div class="level-select-screen" id="level-select-screen">
    <div class="modal">
     <h2>üéØ Multiplication Sky Runner</h2>
     <p>Choose your difficulty level:</p>
     <div class="level-buttons"><button class="btn level-btn" onclick="startGameAtLevel(1)">
       <div class="level-title">
        Level 1
       </div>
       <div class="level-desc">
        1 √ó 1 digit
       </div>
       <div class="level-example">
        Example: 3 √ó 7
       </div></button> <button class="btn level-btn" onclick="startGameAtLevel(2)">
       <div class="level-title">
        Level 2
       </div>
       <div class="level-desc">
        2 √ó 1 digit
       </div>
       <div class="level-example">
        Example: 23 √ó 4
       </div></button> <button class="btn level-btn" onclick="startGameAtLevel(3)">
       <div class="level-title">
        Level 3
       </div>
       <div class="level-desc">
        3 √ó 2 digit
       </div>
       <div class="level-example">
        Example: 145 √ó 12
       </div></button>
     </div>
    </div>
   </div>
  </div>
  <script>
        let game; // <-- BUG FIX: Declare game variable in the global scope

        // MODIFICATION: Add audio variables
        let correctSound;
        let wrongSound;
        let audioInitialized = false;

        async function initializeAudio() {
            if (audioInitialized) return;
            try {
                await Tone.start();
                // Cheerful sound for correct answer (rising arpeggio)
                correctSound = new Tone.Synth().toDestination();
                // Failure sound for incorrect answer
                wrongSound = new Tone.FMSynth({
                    harmonicity: 2,
                    modulationIndex: 10,
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
                }).toDestination();
                audioInitialized = true;
                console.log("Audio initialized.");
            } catch (e) {
                console.error("Audio could not be initialized:", e);
            }
        }

        function playCorrectSound() {
            if (!audioInitialized) return;
            // Play a bright, rising arpeggio
            const now = Tone.now();
            correctSound.triggerAttackRelease("C4", "8n", now);
            correctSound.triggerAttackRelease("E4", "8n", now + 0.1);
            correctSound.triggerAttackRelease("G4", "8n", now + 0.2);
        }

        function playWrongSound() {
            if (!audioInitialized) return;
            // Play a low, dissonant buzz
            wrongSound.triggerAttackRelease("F#2", "4n");
        }


        class MultiplicationGame {
            constructor() {
                this.level = 1;
                this.lives = 3;
                this.score = 0;
                this.currentQuestion = null;
                this.correctAnswer = null;
                this.character = document.getElementById('character');
                this.characterPosition = 250; // Middle position
                this.gameRunning = false;
                this.questionCount = 0;
                this.questionsPerLevel = 10;
                this.activeCandies = new Set();
                this.questionAnswered = false; // BUG FIX: Track if answer was given
                
                this.initializeGame();
                this.setupControls();
                // Don't auto-start level - wait for level selection
            }

            initializeGame() {
                this.character.style.top = this.characterPosition + 'px';
                this.updateUI();
            }

            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            this.moveCharacter(-60);
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            this.moveCharacter(60);
                            break;
                    }
                });

                // Touch controls
                const upBtn = document.getElementById('up-btn');
                const downBtn = document.getElementById('down-btn');

                upBtn.addEventListener('click', () => {
                    if (this.gameRunning) this.moveCharacter(-60);
                });

                downBtn.addEventListener('click', () => {
                    if (this.gameRunning) this.moveCharacter(60);
                });

                // Touch events for better mobile experience
                upBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.gameRunning) this.moveCharacter(-60);
                });

                downBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.gameRunning) this.moveCharacter(60);
                });
            }

            moveCharacter(delta) {
                // MODIFICATION: Changed min position from 70 to 110 for larger UI panel
                this.characterPosition = Math.max(110, Math.min(460, this.characterPosition + delta));
                this.character.style.top = this.characterPosition + 'px';
            }

            generateQuestion() {
                let num1, num2;
                
                switch(this.level) {
                    case 1: // 1 digit √ó 1 digit
                        /* MODIFICATION: Range changed from 1-9 to 2-9 */
                        num1 = Math.floor(Math.random() * 8) + 2;
                        num2 = Math.floor(Math.random() * 8) + 2;
                        break;
                    case 2: // 2 digits √ó 1 digit
                        num1 = Math.floor(Math.random() * 90) + 10;
                        /* MODIFICATION: Range changed from 1-9 to 2-9 */
                        num2 = Math.floor(Math.random() * 8) + 2;
                        break;
                    case 3: // 2-3 digits √ó 2 digits
                        num1 = Math.floor(Math.random() * 900) + 100;
                        num2 = Math.floor(Math.random() * 90) + 10;
                        break;
                }
                
                this.correctAnswer = num1 * num2;
                this.currentQuestion = `${num1} √ó ${num2} = ?`;
                this.questionAnswered = false; // BUG FIX: Reset answer flag
                
                document.getElementById('question').textContent = this.currentQuestion;
                
                this.generateAnswerOptions();
            }

            generateAnswerOptions() {
                // Clear existing options
                document.querySelectorAll('.answer-option').forEach(option => option.remove());
                
                // MODIFICATION: Changed top position from 90 to 120
                const positions = [120, 280, 440]; // Top, middle, bottom positions
                
                // Generate exactly 2 wrong answers
                const wrongAnswers = [];
                let attempts = 0;
                while(wrongAnswers.length < 2 && attempts < 50) {
                    attempts++;
                    let wrongAnswer;
                    const variation = Math.floor(Math.random() * 20) + 1;
                    
                    if(Math.random() < 0.5) {
                        wrongAnswer = this.correctAnswer + variation;
                    } else {
                        wrongAnswer = Math.max(1, this.correctAnswer - variation);
                    }
                    
                    if(wrongAnswer !== this.correctAnswer && !wrongAnswers.includes(wrongAnswer)) {
                        wrongAnswers.push(wrongAnswer);
                    }
                }
                
                // Ensure we have exactly 2 wrong answers, add fallbacks if needed
                while(wrongAnswers.length < 2) {
                    const fallback = this.correctAnswer + (wrongAnswers.length + 1) * 5;
                    if(!wrongAnswers.includes(fallback)) {
                        wrongAnswers.push(fallback);
                    }
                }
                
                // ALWAYS start with the correct answer, then add wrong answers
                const allAnswers = [this.correctAnswer, wrongAnswers[0], wrongAnswers[1]];
                
                // Shuffle the answers to randomize positions
                for(let i = allAnswers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allAnswers[i], allAnswers[j]] = [allAnswers[j], allAnswers[i]];
                }
                
                // Verify we still have the correct answer after shuffling
                if(!allAnswers.includes(this.correctAnswer)) {
                    console.error('Correct answer missing after shuffle!');
                    allAnswers[0] = this.correctAnswer; // Force correct answer in first position
                }
                
                // Track active candies for this question
                this.activeCandies = new Set();
                
                // MODIFICATION: Add dynamic duration based on level
                let duration = 8; // Default for level 1
                if (this.level === 2) {
                    duration = 10; // Slower for level 2
                } else if (this.level === 3) {
                    duration = 12; // Even slower for level 3
                }

                // Create exactly 3 answer options
                allAnswers.forEach((answer, index) => {
                    const option = document.createElement('div');
                    option.className = 'answer-option';
                    option.textContent = answer;
                    option.style.top = positions[index] + 'px';
                    option.dataset.answer = answer;
                    option.dataset.candyId = `candy_${Date.now()}_${index}`;
                    
                    // MODIFICATION: Set animation duration dynamically
                    option.style.animationDuration = `${duration}s, 2s`;

                    // Add to active candies set
                    this.activeCandies.add(option.dataset.candyId);
                    
                    // Check if this is the correct answer
                    if(parseInt(answer) === parseInt(this.correctAnswer)) {
                        option.classList.add('correct');
                    } else {
                        option.classList.add('wrong');
                    }
                    
                    document.querySelector('.game-container').appendChild(option);
                    
                    // Start collision detection immediately and check continuously
                    const collisionInterval = setInterval(() => {
                        if(!option.parentNode || !this.gameRunning || !this.activeCandies.has(option.dataset.candyId)) {
                            clearInterval(collisionInterval);
                            return;
                        }
                        this.checkCollision(option, collisionInterval);
                    }, 50);
                    
                    // Remove option after animation if not eaten
                    // MODIFICATION: Use dynamic duration
                    setTimeout(() => {
                        if(option.parentNode && this.activeCandies.has(option.dataset.candyId)) {
                            option.remove();
                            this.activeCandies.delete(option.dataset.candyId);
                            clearInterval(collisionInterval);
                        }
                    }, duration * 1000); // Use duration here
                });
                
                // Debug: Log to verify correct answer is present
                console.log('Generated answers:', allAnswers, 'Correct answer:', this.correctAnswer);
                
                // Check if we missed the correct answer after all candies are gone
                // MODIFICATION: Use dynamic duration
                setTimeout(() => {
                    // BUG FIX: Only call handleMiss if no answer was given
                    if(this.activeCandies.size === 0 && this.gameRunning && !this.questionAnswered) {
                        this.handleMiss();
                    }
                }, (duration * 1000) + 100); // Use duration here
            }

            checkCollision(option, collisionInterval) {
                if(!this.gameRunning || !option.parentNode || !this.activeCandies.has(option.dataset.candyId)) return;
                
                const optionRect = option.getBoundingClientRect();
                const characterRect = this.character.getBoundingClientRect();
                
                // Check if candy has moved off screen (left side)
                if(optionRect.right < 0) {
                    return; // Let it naturally disappear, don't clear interval here
                }
                
                // More generous collision detection
                const collision = !(optionRect.right < characterRect.left - 10 || 
                                  optionRect.left > characterRect.right + 10 || 
                                  optionRect.bottom < characterRect.top - 10 || 
                                  optionRect.top > characterRect.bottom + 10);
                
                if(collision) {
                    const answer = parseInt(option.dataset.answer);
                    const isCorrect = option.classList.contains('correct');
                    const candyId = option.dataset.candyId;
                    
                    // Mark this option as caught to prevent multiple triggers
                    if(option.dataset.caught) return;
                    option.dataset.caught = 'true';
                    
                    // Remove from active candies
                    this.activeCandies.delete(candyId);
                    
                    option.remove();
                    clearInterval(collisionInterval);
                    
                    // Clear any remaining options since we caught one
                    document.querySelectorAll('.answer-option').forEach(opt => {
                        if(opt !== option && this.activeCandies.has(opt.dataset.candyId)) {
                            this.activeCandies.delete(opt.dataset.candyId);
                            opt.remove();
                        }
                    });
                    
                    if(isCorrect) {
                        this.handleCorrectAnswer();
                    } else {
                        this.handleWrongAnswer();
                    }
                }
            }

            handleCorrectAnswer() {
                playCorrectSound(); // MODIFICATION: Play correct sound
                this.questionAnswered = true; // BUG FIX: Flag that answer was given
                this.score += 1;
                this.questionCount++;
                this.showFeedback('Correct! +1 Point', 'correct');
                this.updateUI();
                
                if(this.questionCount >= this.questionsPerLevel && this.level < 3) {
                    // MODIFICATION: Auto-advance to next level
                    this.level++;
                    this.lives = Math.min(3, this.lives + 1); // Bonus life
                    this.questionCount = 0; // Reset question count for new level
                    this.showFeedback(`Level ${this.level}!`, 'correct');
                    this.updateUI();
                    setTimeout(() => this.generateQuestion(), 1500);
                } else {
                    // MODIFICATION: Just generate next question (keeps going on level 3)
                    setTimeout(() => this.generateQuestion(), 1500);
                }
            }

            handleWrongAnswer() {
                playWrongSound(); // MODIFICATION: Play wrong sound
                this.questionAnswered = true; // BUG FIX: Flag that answer was given
                this.lives--;
                this.showFeedback('Wrong! -1 Life', 'wrong');
                this.updateUI();
                
                if(this.lives <= 0) {
                    this.gameOver();
                } else {
                    setTimeout(() => this.generateQuestion(), 1500);
                }
            }

            handleMiss() {
                playWrongSound(); // MODIFICATION: Play wrong sound
                this.questionAnswered = true; // Flag answer as "missed"
                this.lives--;
                this.showFeedback('Missed! -1 Life', 'wrong');
                this.updateUI();
                
                if(this.lives <= 0) {
                    this.gameOver();
                } else {
                    setTimeout(() => this.generateQuestion(), 1500);
                }
            }

            showFeedback(text, type) {
                const feedback = document.getElementById('feedback');
                feedback.textContent = text;
                feedback.className = `feedback ${type} show`;
                
                setTimeout(() => {
                    feedback.classList.remove('show');
                }, 1000);
            }

            updateUI() {
                document.getElementById('current-level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                
                const livesContainer = document.getElementById('lives-container');
                livesContainer.innerHTML = '';
                for(let i = 0; i < this.lives; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart';
                    livesContainer.appendChild(heart);
                }
            }

            startLevel() {
                this.gameRunning = true;
                this.questionCount = 0;
                this.generateQuestion();
            }

            completeLevel() {
                // MODIFICATION: This function is now unused.
                /*
                this.gameRunning = false;
                
                if(this.level < 3) {
                    document.getElementById('level-complete-screen').style.display = 'flex';
                } else {
                    this.gameWin();
                }
                */
            }

            nextLevel() {
                // MODIFICATION: This function is now unused.
                /*
                this.level++;
                this.lives = Math.min(3, this.lives + 1); // Bonus life for completing level
                document.getElementById('level-complete-screen').style.display = 'none';
                this.updateUI();
                this.startLevel();
                */
            }

            gameWin() {
                // MODIFICATION: This function is now unused.
                /*
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('final-level').textContent = this.level;
                document.querySelector('#game-over-screen h2').textContent = 'Congratulations! üèÜ';
                document.querySelector('#game-over-screen p').innerHTML = 
                    `You completed all levels!<br>Final Score: <span id="final-score">${this.score}</span>`;
                document.getElementById('game-over-screen').style.display = 'flex';
                */
            }

            gameOver() {
                this.gameRunning = false;
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('final-level').textContent = this.level;
                document.getElementById('game-over-screen').style.display = 'flex';
            }
        
        } // <!-- BUG FIX: Added closing brace for MultiplicationGame class

        function restartGame() {
            document.getElementById('level-select-screen').style.display = 'flex';
            document.getElementById('game-over-screen').style.display = 'none';
        }

        function nextLevel() {
            // MODIFICATION: This function is now unused.
            // game.nextLevel();
        }

        // MODIFICATION: Made this function async to await audio initialization
        async function startGameAtLevel(selectedLevel) {
            // MODIFICATION: Now 'await'ing this to ensure audio is ready
            await initializeAudio(); 
            
            document.getElementById('level-select-screen').style.display = 'none';
            game = new MultiplicationGame();
            game.level = selectedLevel;
            game.updateUI();
            game.startLevel();
        }

        // Initialize level selection when page loads
        window.addEventListener('load', () => {
            // Show level selection screen instead of starting game immediately
            document.getElementById('level-select-screen').style.display = 'flex';
        });

        // Initialize Element SDK
        if (window.elementSdk) {
            const defaultConfig = {
                game_title: "Multiplication Sky Runner",
                character_emoji: "üê∞"
            };

            window.elementSdk.init({
                defaultConfig,
                // BUG FIX: Correctly update game title and character emoji
                onConfigChange: async (config) => {
                    const gameTitle = config.game_title || defaultConfig.game_title;
                    const characterEmoji = config.character_emoji || defaultConfig.character_emoji;

                    // Update game title on level select screen
                    const titleElement = document.querySelector('#level-select-screen h2');
                    if (titleElement) {
                        titleElement.innerHTML = `üéØ ${gameTitle}`;
                    }
                    
                    // Update character emoji via CSS variable
                    // Need to wrap the emoji in quotes for the 'content' property
                    document.documentElement.style.setProperty('--character-emoji', `'${characterEmoji}'`);
                },
                mapToCapabilities: (config) => ({
                    recolorables: [],
                    borderables: [],
                    fontEditable: undefined,
                    fontSizeable: undefined
                }),
                mapToEditPanelValues: (config) => new Map([
                    ["game_title", config.game_title || defaultConfig.game_title],
                    ["character_emoji", config.character_emoji || defaultConfig.character_emoji]
                ])
            });
        }
    </script>
  <!-- CLEANUP: Removed malformed Cloudflare script -->
 </body>
</html>
