<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplication Sky Runner</title>
  <script src="/_sdk/element_sdk.js"></script>
  <!-- MODIFICATION: Add Tone.js for audio -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
            height: 100%;
            overflow: hidden;
            user-select: none;
        }

        html {
            height: 100%;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 600px;
        }

        .clouds {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(ellipse 80px 40px at 100px 100px, white 40%, transparent 50%),
                radial-gradient(ellipse 60px 30px at 200px 50px, white 40%, transparent 50%),
                radial-gradient(ellipse 100px 50px at 300px 120px, white 40%, transparent 50%),
                radial-gradient(ellipse 70px 35px at 450px 80px, white 40%, transparent 50%),
                radial-gradient(ellipse 90px 45px at 550px 150px, white 40%, transparent 50%),
                radial-gradient(ellipse 80px 40px at 700px 100px, white 40%, transparent 50%),
                radial-gradient(ellipse 60px 30px at 850px 60px, white 40%, transparent 50%),
                radial-gradient(ellipse 100px 50px at 950px 130px, white 40%, transparent 50%);
            background-size: 1000px 200px;
            animation: moveClouds 20s linear infinite;
        }

        @keyframes moveClouds {
            0% { background-position: 0 0; }
            100% { background-position: -1000px 0; }
        }

        .character {
            position: absolute;
            /* MODIFICATION: Reverted back to emoji style */
            font-size: 50px;
            cursor: pointer;
            transition: top 0.1s;
            z-index: 100;
        }

        .answer-option {
            position: absolute;
            font-size: 40px; /* MODIFICATION: Doubled size */
            color: black; /* MODIFICATION: Changed to black */
            font-weight: bold; /* MODIFICATION: Added bold */
            padding: 15px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 50;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 2px white;
            
            /* MODIFICATION: Use transform for smooth animation */
            right: -100px; /* Start off-screen */
            animation-name: moveAnswer, bubbleBob;
            animation-timing-function: linear, ease-in-out;
            animation-iteration-count: 1, infinite;
            animation-direction: normal, alternate;
            animation-fill-mode: forwards, none;

            /* MODIFICATION: Reverted to original colors */
            background: #f0f0f0; /* Default light gray */
            border: 3px solid #ccc; /* Default border */
        }
        
        /* MODIFICATION: Added correct class back */
        .answer-option.correct {
            background: #a5d6a7; /* Light green */
            border: 3px solid #66bb6a; /* Darker green */
        }
        
        /* MODIFICATION: Keyframes use transform instead of 'right' */
        @keyframes moveAnswer {
            0% {
                transform: translateX(0);
                right: -100px; /* Initial position */
            }
            100% {
                transform: translateX(-110vw); /* Move across the viewport */
                right: -100px; /* Keep 'right' consistent */
            }
        }


        @keyframes bubbleBob {
            0% { transform: translateY(0); }
            100% { transform: translateY(-10px); }
        }

        .ui-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            padding: 40px 20px; /* MODIFICATION: Doubled padding */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            z-index: 200;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
        }
        
        /* MODIFICATION: Layout for top panel */
        .stats-left {
            display: flex;
            align-items: center;
            gap: 20px; /* MODIFICATION: Added gap */
        }

        #question {
            font-size: 48px; /* MODIFICATION: Doubled size */
            color: #333;
            text-shadow: 1px 1px 1px #fff;
            flex-grow: 1;
            text-align: center;
        }

        #level-display, #lives-display {
            color: #d9534f;
            background: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        #score-display {
            color: #5cb85c;
            background: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }


        .start-screen, .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: white;
            text-align: center;
        }

        .start-screen h1 {
            font-size: 48px;
            text-shadow: 2px 2px 4px #000;
        }
        
        .start-screen p {
            font-size: 24px;
            margin-bottom: 30px;
        }

        .level-select button {
            font-size: 24px;
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: #5cb85c;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 0 #449d44;
            transition: all 0.1s;
        }

        .level-select button:active {
            box-shadow: 0 2px 0 #449d44;
            transform: translateY(2px);
        }

        .game-over-screen h2 {
            font-size: 48px;
            color: #d9534f;
            text-shadow: 2px 2px 4px #000;
        }
        
        #final-score {
            font-size: 36px;
            margin: 20px 0;
        }

        #restart-button {
            font-size: 24px;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: #f0ad4e;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 0 #eea236;
            transition: all 0.1s;
        }
        
        #restart-button:active {
            box-shadow: 0 2px 0 #eea236;
            transform: translateY(2px);
        }

  </style>
 </head>
 <body>

  <div class="game-container" id="game-container">
   <div class="clouds"></div>

   <!-- MODIFICATION: Updated UI Panel Structure -->
   <div class="ui-panel">
        <div class="stats-left">
            <div id="level-display">Level: 1</div>
            <div id="lives-display">Lives: 3 ‚ù§Ô∏è</div>
        </div>
        <div id="question">1 x 1 = ?</div>
        <div id="score-display">Score: 0</div>
   </div>
   <!-- END MODIFICATION -->


   <div class="character" id="character"></div>

   <div class="start-screen" id="start-screen">
       <h1 id="game-title">Multiplication Sky Runner</h1>
       <p>Select your starting level:</p>
       <div class="level-select">
           <button onclick="startGameAtLevel(1)">Level 1 (x1-x5)</button>
           <button onclick="startGameAtLevel(2)">Level 2 (x6-x9)</button>
           <button onclick="startGameAtLevel(3)">Level 3 (x2-x9)</button>
       </div>
   </div>
   
   <div class="game-over-screen" id="game-over-screen" style="display: none;">
       <h2>Game Over!</h2>
       <div id="final-score">Final Score: 0</div>
       <button id="restart-button" onclick="restartGame()">Play Again</button>
   </div>

  </div>

  <script>
        // MODIFICATION: Add audio variables
        let correctSound;
        let wrongSound;
        let crashSound; // MODIFICATION: Added new synth for crashing
        let audioInitialized = false;

        async function initializeAudio() {
            if (audioInitialized) return;
            try {
                await Tone.start();
                
                // Sound for correct answer
                correctSound = new Tone.PolySynth(Tone.Synth, {
                    volume: -10,
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
                }).toDestination();
                
                // Sound for missing (wrong sound)
                wrongSound = new Tone.Synth({
                    volume: -5,
                    oscillator: { type: "square" },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
                }).toDestination();
                
                // MODIFICATION: Add a crash sound for wrong answers
                crashSound = new Tone.NoiseSynth({
                    noise: {
                        type: 'white'
                    },
                    envelope: {
                        attack: 0.005,
                        decay: 0.1,
                        sustain: 0,
                        release: 0.1
                    }
                }).toDestination();
                
                audioInitialized = true;
                console.log("Audio initialized.");
            } catch (e) {
                console.error("Audio could not be started: ", e);
            }
        }
        
        function playCorrectSound() {
            if (!audioInitialized) return;
            const now = Tone.now();
            // Play a cheerful, rising arpeggio
            correctSound.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", now);
        }
        
        function playWrongSound() {
            if (!audioInitialized) return;
            // Play a low "miss" buzz
            wrongSound.triggerAttackRelease("F#2", "4n");
        }

        // MODIFICATION: Added new function for crash sound
        function playCrashSound() {
            if (!audioInitialized) return;
            // Play a short, sharp noise burst
            crashSound.triggerAttackRelease("8n");
        }

        // MODIFICATION: Moved game variable to global scope
        let game;

        class MultiplicationGame {
            constructor(startLevel = 1) {
                this.character = document.getElementById('character');
                this.gameContainer = document.getElementById('game-container');
                this.questionEl = document.getElementById('question');
                this.levelDisplay = document.getElementById('level-display');
                this.livesDisplay = document.getElementById('lives-display');
                this.scoreDisplay = document.getElementById('score-display');
                
                this.level = startLevel;
                this.lives = 3;
                this.score = 0;
                this.gameRunning = false;
                
                // MODIFICATION: Get UI panel height dynamically
                this.uiPanel = document.querySelector('.ui-panel');
                this.uiPanelHeight = this.uiPanel.offsetHeight;
                
                this.containerHeight = this.gameContainer.clientHeight;
                this.characterHeight = this.character.clientHeight;
                
                // MODIFICATION: Character can move from just below UI panel to bottom
                this.minTop = this.uiPanelHeight + 10; 
                this.maxTop = this.containerHeight - this.characterHeight - 10;
                
                this.character.style.top = (this.containerHeight / 2) + 'px';
                this.character.style.left = '20px';
                
                this.questionCount = 0;
                this.questionsPerLevel = 10;
                this.activeCandies = new Set();
                this.activeIntervals = new Map(); // MODIFICATION: Track active intervals
                this.questionAnswered = false; // BUG FIX: Track if answer was given
                
                this.initializeGame();
                this.bindEvents();
            }

            initializeGame() {
                this.updateStats();
                this.gameRunning = true;
                this.nextQuestion();
            }

            bindEvents() {
                // Mouse movement
                this.gameContainer.addEventListener('mousemove', this.moveCharacter.bind(this));
                
                // Touch movement
                this.gameContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault(); // Prevent scrolling
                    this.moveCharacter(e.touches[0]);
                }, { passive: false });
            }

            moveCharacter(e) {
                if (!this.gameRunning) return;
                let y = e.clientY - this.gameContainer.getBoundingClientRect().top;
                
                // Constrain character movement
                if (y < this.minTop) y = this.minTop;
                if (y > this.maxTop) y = this.maxTop;
                
                this.character.style.top = y + 'px';
            }

            updateStats() {
                this.levelDisplay.textContent = `Level: ${this.level}`;
                this.livesDisplay.textContent = `Lives: ${this.lives} ‚ù§Ô∏è`;
                this.scoreDisplay.textContent = `Score: ${this.score}`;
            }

            generateQuestion() {
                let num1, num2;
                
                // MODIFICATION: Remove multiplication by 1
                if (this.level === 1) {
                    num1 = this.getRandomInt(2, 5);
                    num2 = this.getRandomInt(2, 5);
                } else if (this.level === 2) {
                    num1 = this.getRandomInt(6, 9);
                    num2 = this.getRandomInt(2, 9);
                } else { // Level 3 and beyond
                    num1 = this.getRandomInt(2, 9);
                    num2 = this.getRandomInt(2, 9);
                }
                
                const answer = num1 * num2;
                this.questionEl.textContent = `${num1} x ${num2} = ?`;
                
                return answer;
            }

            generateAnswers(correctAnswer) {
                let answers = new Set([correctAnswer]);
                
                // Generate 3 wrong answers
                while (answers.size < 4) {
                    let wrongAnswer;
                    const offset = this.getRandomInt(1, 5) * (Math.random() < 0.5 ? 1 : -1);
                    wrongAnswer = correctAnswer + offset;
                    
                    if (wrongAnswer > 0 && wrongAnswer !== correctAnswer) {
                        answers.add(wrongAnswer);
                    } else {
                        // Fallback for tricky answers (e.g., answer = 1)
                        wrongAnswer = correctAnswer + this.getRandomInt(1, 5) + 1;
                        answers.add(wrongAnswer);
                    }
                }
                
                return this.shuffleArray(Array.from(answers));
            }

            nextQuestion() {
                if (!this.gameRunning) return;
                
                this.questionAnswered = false; // BUG FIX: Reset for new question
                
                // MODIFICATION: Handle level progression
                if (this.questionCount >= this.questionsPerLevel) {
                    this.questionCount = 0;
                    if(this.level < 3) {
                        this.level++;
                        this.lives++; // Bonus life for leveling up
                        this.updateStats();
                    }
                    // No score limit, just continue at Level 3
                }
                
                const correctAnswer = this.generateQuestion();
                const allAnswers = this.generateAnswers(correctAnswer);
                
                // Clear old answers
                document.querySelectorAll('.answer-option').forEach(opt => opt.remove());
                
                // MODIFICATION: Get UI panel height dynamically
                this.uiPanelHeight = this.uiPanel.offsetHeight;
                const spawnAreaHeight = this.gameContainer.clientHeight - this.uiPanelHeight;
                const spawnPadding = 50; // Padding from top/bottom
                
                // Create 4 positions, ensuring they don't overlap
                let positions = [];
                const optionHeight = 80; // height of candy
                const spacing = (spawnAreaHeight - (4 * optionHeight) - (2 * spawnPadding)) / 3;
                
                for (let i = 0; i < 4; i++) {
                    // Position from top of game container
                    let pos = this.uiPanelHeight + spawnPadding + i * (optionHeight + spacing);
                    positions.push(pos);
                }
                positions = this.shuffleArray(positions);
                
                
                // Track active candies for this question
                this.activeCandies = new Set();
                this.activeIntervals.clear(); // MODIFICATION: Clear any old intervals
                
                // MODIFICATION: Add dynamic duration based on level
                let duration;
                if(this.level === 1) duration = 8;  // 8 seconds
                else if(this.level === 2) duration = 10; // 10 seconds
                else duration = 12; // 12 seconds
                
                allAnswers.forEach((answer, index) => {
                    const option = document.createElement('div');
                    option.classList.add('answer-option');
                    // MODIFICATION: Removed conflicting/old innerHTML line.
                    // option.innerHTML = `üç¨<span class="candy-number">${answer}</span>`;
                    option.textContent = answer;
                    option.style.top = positions[index] + 'px';
                    option.dataset.answer = answer;
                    // MODIFICATION: Get candyId earlier to use for interval map
                    const candyId = `candy_${Date.now()}_${index}`;
                    option.dataset.candyId = candyId;
                    
                    // MODIFICATION: Set animation duration dynamically
                    option.style.animationDuration = `${duration}s, 2s`;

                    // Add to active candies set
                    this.activeCandies.add(candyId);
                    
                    // Check if this is the correct answer
                    if (answer === correctAnswer) {
                        option.classList.add('correct');
                    }
                    
                    this.gameContainer.appendChild(option);
                    
                    // Start collision detection immediately and check continuously
                    const collisionInterval = setInterval(() => {
                        if(!option.parentNode || !this.gameRunning || !this.activeCandies.has(option.dataset.candyId)) {
                            clearInterval(collisionInterval);
                            this.activeIntervals.delete(candyId); // MODIFICATION: Clean up map
                            return;
                        }
                        this.checkCollision(option, collisionInterval);
                    }, 50);

                    // MODIFICATION: Store interval
                    this.activeIntervals.set(candyId, collisionInterval);
                    
                    // Remove option after animation if not eaten
                    setTimeout(() => {
                        if(option.parentNode && this.activeCandies.has(option.dataset.candyId)) {
                            option.remove();
                            this.activeCandies.delete(option.dataset.candyId);
                            clearInterval(collisionInterval);
                            this.activeIntervals.delete(candyId); // MODIFICATION: Clean up map
                        }
                    }, duration * 1000); // Use duration here
                });
                
                this.questionCount++;
            }

            checkCollision(option, collisionInterval) {
                // MODIFICATION: Get candyId at the top
                const candyId = option.dataset.candyId;
                // MODIFICATION: Add interval clearing to guard clause
                if(!this.gameRunning || !option.parentNode || !this.activeCandies.has(candyId)) {
                    clearInterval(collisionInterval);
                    this.activeIntervals.delete(candyId);
                    return;
                }
                
                const optionRect = option.getBoundingClientRect();
                const charRect = this.character.getBoundingClientRect();
                
                // Check if candy is off-screen
                if(optionRect.right < 0) {
                    // MODIFICATION: Check if the missed candy was the correct one
                    const isCorrect = option.classList.contains('correct');

                    // Only trigger miss if this is the correct candy and it's still active
                    if (isCorrect && this.gameRunning && this.activeCandies.has(candyId) && !this.questionAnswered) {
                        // This is a "miss".
                        
                        // Clear this interval
                        clearInterval(collisionInterval);
                        this.activeIntervals.delete(candyId); // MODIFICATION: Clean up map
                        
                        // Remove this candy from active set
                        this.activeCandies.delete(candyId);
                        
                        // Call miss handler
                        this.handleMiss();
                        
                        // Clear any remaining options
                        document.querySelectorAll('.answer-option').forEach(opt => {
                            // MODIFICATION: Clear intervals for other candies
                            const optId = opt.dataset.candyId;
                            if(this.activeCandies.has(optId)) {
                                this.activeCandies.delete(optId);
                                if (opt.parentNode) opt.remove();
                                
                                const intervalToClear = this.activeIntervals.get(optId);
                                if (intervalToClear) {
                                    clearInterval(intervalToClear);
                                    this.activeIntervals.delete(optId);
                                }
                            }
                        });

                    } else if (this.activeCandies.has(candyId)) {
                        // It's a wrong candy that went off-screen. Just clean it up.
                        clearInterval(collisionInterval);
                        this.activeIntervals.delete(candyId); // MODIFICATION: Clean up map
                        this.activeCandies.delete(candyId);
                        if(option.parentNode) {
                            option.remove();
                        }
                    }
                    return;
                }
                
                // Check for collision with character
                const collision = !(charRect.right < optionRect.left || 
                                  charRect.left > optionRect.right || 
                                  charRect.bottom < optionRect.top || 
                                  charRect.top > optionRect.bottom);
                
                if(collision) {
                    const answer = parseInt(option.dataset.answer);
                    const isCorrect = option.classList.contains('correct');
                    
                    // Mark this option as caught to prevent multiple triggers
                    this.activeCandies.delete(candyId);
                    
                    option.remove();
                    clearInterval(collisionInterval);
                    this.activeIntervals.delete(candyId); // MODIFICATION: Clean up map
                    
                    // Clear any remaining options since we caught one
                    document.querySelectorAll('.answer-option').forEach(opt => {
                        // MODIFICATION: Clear intervals for other candies
                        const optId = opt.dataset.candyId;
                        if(opt !== option && this.activeCandies.has(optId)) {
                            this.activeCandies.delete(optId);
                            opt.remove();

                            const intervalToClear = this.activeIntervals.get(optId);
                            if (intervalToClear) {
                                clearInterval(intervalToClear);
                                this.activeIntervals.delete(optId);
                            }
                        }
                    });
                    
                    if(isCorrect) {
                        this.handleCorrectAnswer();
                    } else {
                        this.handleWrongAnswer();
                    }
                }
            }
            
            handleCorrectAnswer() {
                playCorrectSound();
                this.questionAnswered = true; // BUG FIX: Flag that answer was given
                this.score += (10 * this.level);
                this.updateStats();
                setTimeout(() => this.nextQuestion(), 500); // Wait half a sec
            }

            handleWrongAnswer() {
                // MODIFICATION: Changed to play crash sound
                playCrashSound();
                this.questionAnswered = true; // BUG FIX: Flag that answer was given
                this.lives--;
                this.updateStats();
                
                // MODIFICATION: Removed crying character logic
                
                if (this.lives <= 0) {
                    this.endGame();
                } else {
                    setTimeout(() => this.nextQuestion(), 500); // Wait half a sec
                }
            }
            
            handleMiss() {
                playWrongSound(); // MODIFICATION: Play sound on miss
                this.questionAnswered = true; // BUG FIX: Flag that answer was given
                this.lives--;
                this.updateStats();
                if (this.lives <= 0) {
                    this.endGame();
                } else {
                    setTimeout(() => this.nextQuestion(), 500); // Wait half a sec
                }
            }

            endGame() {
                this.gameRunning = false;
                
                // Clear all intervals
                this.activeIntervals.forEach((interval, id) => {
                    clearInterval(interval);
                });
                this.activeIntervals.clear();
                this.activeCandies.clear();
                
                // Remove any remaining candies
                document.querySelectorAll('.answer-option').forEach(opt => opt.remove());
                
                document.getElementById('final-score').textContent = `Final Score: ${this.score}`;
                document.getElementById('game-over-screen').style.display = 'flex';
            }

            getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }
        
        // MODIFICATION: Make async and await audio init
        async function startGameAtLevel(level) {
            // MODIFICATION: Await audio initialization
            await initializeAudio();
            
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            
            // Clean up old game if it exists
            if (game) {
                game.gameRunning = false; // Stop old game loops
                // Clear all intervals
                game.activeIntervals.forEach((interval, id) => {
                    clearInterval(interval);
                });
                game.activeIntervals.clear();
                game.activeCandies.clear();
            }
            
            game = new MultiplicationGame(level);
        }
        
        function restartGame() {
            // Re-show start screen
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
            
            // MODIFICATION: Removed character image reset
        }

        // --- Element SDK Integration ---
        if (window.ElementSDK) {
            const sdk = window.ElementSDK.init();
            
            const defaultConfig = {
                game_title: "Multiplication Sky Runner",
                // MODIFICATION: Added emoji back
                character_emoji: "‚úàÔ∏è"
            };
            
            // MODIFICATION: Set default emoji on load
            document.getElementById('character').textContent = defaultConfig.character_emoji;
            
            sdk.onConfigDidChange((config) => {
                const title = config.game_title || defaultConfig.game_title;
                document.getElementById('game-title').textContent = title;
                // MODIFICATION: Set character emoji
                const characterEmoji = config.character_emoji || defaultConfig.character_emoji;
                document.getElementById('character').textContent = characterEmoji;
            });
            
            sdk.readiness.setReady();
            
            // Expose capabilities
            sdk.expose.capabilities({
                config: {
                    props: [
                        {
                            id: "game_title",
                            label: "Game Title",
                            type: "text"
                        },
                        // MODIFICATION: Added emoji setting back
                        {
                            id: "character_emoji",
                            label: "Character Emoji",
                            type: "text"
                        }
                    ]
                },
                mapToCapabilities: (config) => ({
                    recolorables: [],
                    borderables: [],
                    fontEditable: undefined,
                    fontSizeable: undefined
                }),
                mapToEditPanelValues: (config) => new Map([
                    ["game_title", config.game_title || defaultConfig.game_title],
                    // MODIFICATION: Add emoji back
                    ["character_emoji", config.character_emoji || defaultConfig.character_emoji]
                ])
            });
        }
  </script>
 </body>
</html>
